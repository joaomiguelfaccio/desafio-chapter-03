{"ast":null,"code":"/// <reference types=\"cypress\" />\n// @ts-check\nvar _require = require('./support-utils'),\n    filterSpecsFromCoverage = _require.filterSpecsFromCoverage;\n/**\n * Sends collected code coverage object to the backend code\n * via \"cy.task\".\n */\n\n\nvar sendCoverage = function sendCoverage(coverage) {\n  var pathname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';\n  logMessage(\"Saving code coverage for **\".concat(pathname, \"**\"));\n  var withoutSpecs = filterSpecsFromCoverage(coverage);\n  var appCoverageOnly = filterSupportFilesFromCoverage(withoutSpecs); // stringify coverage object for speed\n\n  cy.task('combineCoverage', JSON.stringify(appCoverageOnly), {\n    log: false\n  });\n};\n/**\n * Consistently logs the given string to the Command Log\n * so the user knows the log message is coming from this plugin.\n * @param {string} s Message to log.\n */\n\n\nvar logMessage = function logMessage(s) {\n  cy.log(\"\".concat(s, \" `[@cypress/code-coverage]`\"));\n};\n/**\n * Removes support file from the coverage object.\n * If there are more files loaded from support folder, also removes them\n */\n\n\nvar filterSupportFilesFromCoverage = function filterSupportFilesFromCoverage(totalCoverage) {\n  var integrationFolder = Cypress.config('integrationFolder');\n  var supportFile = Cypress.config('supportFile');\n  /** @type {string} Cypress run-time config has the support folder string */\n  // @ts-ignore\n\n  var supportFolder = Cypress.config('supportFolder');\n\n  var isSupportFile = function isSupportFile(filename) {\n    return filename === supportFile;\n  };\n\n  var coverage = Cypress._.omitBy(totalCoverage, function (fileCoverage, filename) {\n    return isSupportFile(filename);\n  }); // check the edge case\n  //   if we have files from support folder AND the support folder is not same\n  //   as the integration, or its prefix (this might remove all app source files)\n  //   then remove all files from the support folder\n\n\n  if (!integrationFolder.startsWith(supportFolder)) {\n    // remove all covered files from support folder\n    coverage = Cypress._.omitBy(totalCoverage, function (fileCoverage, filename) {\n      return filename.startsWith(supportFolder);\n    });\n  }\n\n  return coverage;\n};\n\nvar registerHooks = function registerHooks() {\n  var windowCoverageObjects;\n\n  var hasE2ECoverage = function hasE2ECoverage() {\n    return Boolean(windowCoverageObjects.length);\n  }; // @ts-ignore\n\n\n  var hasUnitTestCoverage = function hasUnitTestCoverage() {\n    return Boolean(window.__coverage__);\n  };\n\n  before(function () {\n    // we need to reset the coverage when running\n    // in the interactive mode, otherwise the counters will\n    // keep increasing every time we rerun the tests\n    var logInstance = Cypress.log({\n      name: 'Coverage',\n      message: ['Reset [@cypress/code-coverage]']\n    });\n    cy.task('resetCoverage', {\n      // @ts-ignore\n      isInteractive: Cypress.config('isInteractive')\n    }, {\n      log: false\n    }).then(function () {\n      logInstance.end();\n    });\n  });\n  beforeEach(function () {\n    // each object will have the coverage and url pathname\n    // to let the user know the coverage has been collected\n    windowCoverageObjects = [];\n\n    var saveCoverageObject = function saveCoverageObject(win) {\n      // if application code has been instrumented, the app iframe \"window\" has an object\n      var applicationSourceCoverage = win.__coverage__;\n\n      if (!applicationSourceCoverage) {\n        return;\n      }\n\n      if (Cypress._.find(windowCoverageObjects, {\n        coverage: applicationSourceCoverage\n      })) {\n        // this application code coverage object is already known\n        // which can happen when combining `window:load` and `before` callbacks\n        return;\n      }\n\n      windowCoverageObjects.push({\n        coverage: applicationSourceCoverage,\n        pathname: win.location.pathname\n      });\n    }; // save reference to coverage for each app window loaded in the test\n\n\n    cy.on('window:load', saveCoverageObject); // save reference if visiting a page inside a before() hook\n\n    cy.window({\n      log: false\n    }).then(saveCoverageObject);\n  });\n  afterEach(function () {\n    // save coverage after the test\n    // because now the window coverage objects have been updated\n    windowCoverageObjects.forEach(function (cover) {\n      sendCoverage(cover.coverage, cover.pathname);\n    });\n\n    if (!hasE2ECoverage()) {\n      if (hasUnitTestCoverage()) {\n        logMessage(\"\\uD83D\\uDC49 Only found unit test code coverage.\");\n      } else {\n        logMessage(\"\\n          \\u26A0\\uFE0F Could not find any coverage information in your application\\n          by looking at the window coverage object.\\n          Did you forget to instrument your application?\\n          See [code-coverage#instrument-your-application](https://github.com/cypress-io/code-coverage#instrument-your-application)\\n        \");\n      }\n    }\n  });\n  after(function collectBackendCoverage() {\n    // I wish I could fail the tests if there is no code coverage information\n    // but throwing an error here does not fail the test run due to\n    // https://github.com/cypress-io/cypress/issues/2296\n    // there might be server-side code coverage information\n    // we should grab it once after all tests finish\n    // @ts-ignore\n    var baseUrl = Cypress.config('baseUrl') || cy.state('window').origin; // @ts-ignore\n\n    var runningEndToEndTests = baseUrl !== Cypress.config('proxyUrl');\n\n    var specType = Cypress._.get(Cypress.spec, 'specType', 'integration');\n\n    var isIntegrationSpec = specType === 'integration';\n\n    if (runningEndToEndTests && isIntegrationSpec) {\n      // we can only request server-side code coverage\n      // if we are running end-to-end tests,\n      // otherwise where do we send the request?\n      var url = Cypress._.get(Cypress.env('codeCoverage'), 'url', '/__coverage__');\n\n      cy.request({\n        url: url,\n        log: false,\n        failOnStatusCode: false\n      }).then(function (r) {\n        return Cypress._.get(r, 'body.coverage', null);\n      }).then(function (coverage) {\n        if (!coverage) {\n          // we did not get code coverage - this is the\n          // original failed request\n          return;\n        }\n\n        sendCoverage(coverage, 'backend');\n      });\n    }\n  });\n  after(function mergeUnitTestCoverage() {\n    // collect and merge frontend coverage\n    // if spec bundle has been instrumented (using Cypress preprocessor)\n    // then we will have unit test coverage\n    // NOTE: spec iframe is NOT reset between the tests, so we can grab\n    // the coverage information only once after all tests have finished\n    // @ts-ignore\n    var unitTestCoverage = window.__coverage__;\n\n    if (unitTestCoverage) {\n      sendCoverage(unitTestCoverage, 'unit');\n    }\n  });\n  after(function generateReport() {\n    // when all tests finish, lets generate the coverage report\n    var logInstance = Cypress.log({\n      name: 'Coverage',\n      message: ['Generating report [@cypress/code-coverage]']\n    });\n    cy.task('coverageReport', null, {\n      timeout: Cypress.moment.duration(3, 'minutes').asMilliseconds(),\n      log: false\n    }).then(function (coverageReportFolder) {\n      logInstance.set('consoleProps', function () {\n        return {\n          'coverage report folder': coverageReportFolder\n        };\n      });\n      logInstance.end();\n      return coverageReportFolder;\n    });\n  });\n}; // to disable code coverage commands and save time\n// pass environment variable coverage=false\n//  cypress run --env coverage=false\n// or\n//  CYPRESS_coverage=false cypress run\n// see https://on.cypress.io/environment-variables\n// to avoid \"coverage\" env variable being case-sensitive, convert to lowercase\n\n\nvar cyEnvs = Cypress._.mapKeys(Cypress.env(), function (value, key) {\n  return key.toLowerCase();\n});\n\nif (cyEnvs.coverage === false) {\n  console.log('Skipping code coverage hooks');\n} else if (Cypress.env('codeCoverageTasksRegistered') !== true) {\n  // register a hook just to log a message\n  before(function () {\n    logMessage(\"\\n      \\u26A0\\uFE0F Code coverage tasks were not registered by the plugins file.\\n      See [support issue](https://github.com/cypress-io/code-coverage/issues/179)\\n      for possible workarounds.\\n    \");\n  });\n} else {\n  registerHooks();\n}","map":{"version":3,"sources":["/Users/jmiguel/Documents/Agilizei-Bootcamp/Chapter-3/proffy-aglz/web/node_modules/@cypress/code-coverage/support.js"],"names":["require","filterSpecsFromCoverage","sendCoverage","coverage","pathname","logMessage","withoutSpecs","appCoverageOnly","filterSupportFilesFromCoverage","cy","task","JSON","stringify","log","s","totalCoverage","integrationFolder","Cypress","config","supportFile","supportFolder","isSupportFile","filename","_","omitBy","fileCoverage","startsWith","registerHooks","windowCoverageObjects","hasE2ECoverage","Boolean","length","hasUnitTestCoverage","window","__coverage__","before","logInstance","name","message","isInteractive","then","end","beforeEach","saveCoverageObject","win","applicationSourceCoverage","find","push","location","on","afterEach","forEach","cover","after","collectBackendCoverage","baseUrl","state","origin","runningEndToEndTests","specType","get","spec","isIntegrationSpec","url","env","request","failOnStatusCode","r","mergeUnitTestCoverage","unitTestCoverage","generateReport","timeout","moment","duration","asMilliseconds","coverageReportFolder","set","cyEnvs","mapKeys","value","key","toLowerCase","console"],"mappings":"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","sourcesContent":["/// <reference types=\"cypress\" />\n// @ts-check\n\nconst { filterSpecsFromCoverage } = require('./support-utils')\n\n/**\n * Sends collected code coverage object to the backend code\n * via \"cy.task\".\n */\nconst sendCoverage = (coverage, pathname = '/') => {\n  logMessage(`Saving code coverage for **${pathname}**`)\n\n  const withoutSpecs = filterSpecsFromCoverage(coverage)\n  const appCoverageOnly = filterSupportFilesFromCoverage(withoutSpecs)\n\n  // stringify coverage object for speed\n  cy.task('combineCoverage', JSON.stringify(appCoverageOnly), {\n    log: false\n  })\n}\n\n/**\n * Consistently logs the given string to the Command Log\n * so the user knows the log message is coming from this plugin.\n * @param {string} s Message to log.\n */\nconst logMessage = (s) => {\n  cy.log(`${s} \\`[@cypress/code-coverage]\\``)\n}\n\n/**\n * Removes support file from the coverage object.\n * If there are more files loaded from support folder, also removes them\n */\nconst filterSupportFilesFromCoverage = (totalCoverage) => {\n  const integrationFolder = Cypress.config('integrationFolder')\n  const supportFile = Cypress.config('supportFile')\n\n  /** @type {string} Cypress run-time config has the support folder string */\n  // @ts-ignore\n  const supportFolder = Cypress.config('supportFolder')\n\n  const isSupportFile = (filename) => filename === supportFile\n\n  let coverage = Cypress._.omitBy(totalCoverage, (fileCoverage, filename) =>\n    isSupportFile(filename)\n  )\n\n  // check the edge case\n  //   if we have files from support folder AND the support folder is not same\n  //   as the integration, or its prefix (this might remove all app source files)\n  //   then remove all files from the support folder\n  if (!integrationFolder.startsWith(supportFolder)) {\n    // remove all covered files from support folder\n    coverage = Cypress._.omitBy(totalCoverage, (fileCoverage, filename) =>\n      filename.startsWith(supportFolder)\n    )\n  }\n  return coverage\n}\n\nconst registerHooks = () => {\n  let windowCoverageObjects\n\n  const hasE2ECoverage = () => Boolean(windowCoverageObjects.length)\n\n  // @ts-ignore\n  const hasUnitTestCoverage = () => Boolean(window.__coverage__)\n\n  before(() => {\n    // we need to reset the coverage when running\n    // in the interactive mode, otherwise the counters will\n    // keep increasing every time we rerun the tests\n    const logInstance = Cypress.log({\n      name: 'Coverage',\n      message: ['Reset [@cypress/code-coverage]']\n    })\n\n    cy.task(\n      'resetCoverage',\n      {\n        // @ts-ignore\n        isInteractive: Cypress.config('isInteractive')\n      },\n      { log: false }\n    ).then(() => {\n      logInstance.end()\n    })\n  })\n\n  beforeEach(() => {\n    // each object will have the coverage and url pathname\n    // to let the user know the coverage has been collected\n    windowCoverageObjects = []\n\n    const saveCoverageObject = (win) => {\n      // if application code has been instrumented, the app iframe \"window\" has an object\n      const applicationSourceCoverage = win.__coverage__\n      if (!applicationSourceCoverage) {\n        return\n      }\n\n      if (\n        Cypress._.find(windowCoverageObjects, {\n          coverage: applicationSourceCoverage\n        })\n      ) {\n        // this application code coverage object is already known\n        // which can happen when combining `window:load` and `before` callbacks\n        return\n      }\n\n      windowCoverageObjects.push({\n        coverage: applicationSourceCoverage,\n        pathname: win.location.pathname\n      })\n    }\n\n    // save reference to coverage for each app window loaded in the test\n    cy.on('window:load', saveCoverageObject)\n\n    // save reference if visiting a page inside a before() hook\n    cy.window({ log: false }).then(saveCoverageObject)\n  })\n\n  afterEach(() => {\n    // save coverage after the test\n    // because now the window coverage objects have been updated\n    windowCoverageObjects.forEach((cover) => {\n      sendCoverage(cover.coverage, cover.pathname)\n    })\n\n    if (!hasE2ECoverage()) {\n      if (hasUnitTestCoverage()) {\n        logMessage(`👉 Only found unit test code coverage.`)\n      } else {\n        logMessage(`\n          ⚠️ Could not find any coverage information in your application\n          by looking at the window coverage object.\n          Did you forget to instrument your application?\n          See [code-coverage#instrument-your-application](https://github.com/cypress-io/code-coverage#instrument-your-application)\n        `)\n      }\n    }\n  })\n\n  after(function collectBackendCoverage() {\n    // I wish I could fail the tests if there is no code coverage information\n    // but throwing an error here does not fail the test run due to\n    // https://github.com/cypress-io/cypress/issues/2296\n\n    // there might be server-side code coverage information\n    // we should grab it once after all tests finish\n    // @ts-ignore\n    const baseUrl = Cypress.config('baseUrl') || cy.state('window').origin\n    // @ts-ignore\n    const runningEndToEndTests = baseUrl !== Cypress.config('proxyUrl')\n    const specType = Cypress._.get(Cypress.spec, 'specType', 'integration')\n    const isIntegrationSpec = specType === 'integration'\n\n    if (runningEndToEndTests && isIntegrationSpec) {\n      // we can only request server-side code coverage\n      // if we are running end-to-end tests,\n      // otherwise where do we send the request?\n      const url = Cypress._.get(\n        Cypress.env('codeCoverage'),\n        'url',\n        '/__coverage__'\n      )\n      cy.request({\n        url,\n        log: false,\n        failOnStatusCode: false\n      })\n        .then((r) => {\n          return Cypress._.get(r, 'body.coverage', null)\n        })\n        .then((coverage) => {\n          if (!coverage) {\n            // we did not get code coverage - this is the\n            // original failed request\n            return\n          }\n          sendCoverage(coverage, 'backend')\n        })\n    }\n  })\n\n  after(function mergeUnitTestCoverage() {\n    // collect and merge frontend coverage\n\n    // if spec bundle has been instrumented (using Cypress preprocessor)\n    // then we will have unit test coverage\n    // NOTE: spec iframe is NOT reset between the tests, so we can grab\n    // the coverage information only once after all tests have finished\n    // @ts-ignore\n    const unitTestCoverage = window.__coverage__\n    if (unitTestCoverage) {\n      sendCoverage(unitTestCoverage, 'unit')\n    }\n  })\n\n  after(function generateReport() {\n    // when all tests finish, lets generate the coverage report\n    const logInstance = Cypress.log({\n      name: 'Coverage',\n      message: ['Generating report [@cypress/code-coverage]']\n    })\n    cy.task('coverageReport', null, {\n      timeout: Cypress.moment.duration(3, 'minutes').asMilliseconds(),\n      log: false\n    }).then((coverageReportFolder) => {\n      logInstance.set('consoleProps', () => ({\n        'coverage report folder': coverageReportFolder\n      }))\n      logInstance.end()\n      return coverageReportFolder\n    })\n  })\n}\n\n// to disable code coverage commands and save time\n// pass environment variable coverage=false\n//  cypress run --env coverage=false\n// or\n//  CYPRESS_coverage=false cypress run\n// see https://on.cypress.io/environment-variables\n\n// to avoid \"coverage\" env variable being case-sensitive, convert to lowercase\nconst cyEnvs = Cypress._.mapKeys(Cypress.env(), (value, key) =>\n  key.toLowerCase()\n)\n\nif (cyEnvs.coverage === false) {\n  console.log('Skipping code coverage hooks')\n} else if (Cypress.env('codeCoverageTasksRegistered') !== true) {\n  // register a hook just to log a message\n  before(() => {\n    logMessage(`\n      ⚠️ Code coverage tasks were not registered by the plugins file.\n      See [support issue](https://github.com/cypress-io/code-coverage/issues/179)\n      for possible workarounds.\n    `)\n  })\n} else {\n  registerHooks()\n}\n"]},"metadata":{},"sourceType":"script"}